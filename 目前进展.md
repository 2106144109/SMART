### SMART Maritime 项目阶段性总结

#### 当前状态
- 已完成海事数据预处理与一次完整训练流程。
- 交互式可视化已生成 5 个场景，但呈现几乎相同的轨迹形态。

#### 架构要点（简述）
- 训练入口基于 PyTorch Lightning，配置由 YAML 加载，数据通过 `MultiDataModule` 管理，模型为 `SMART`，解码核心在 `SMARTDecoder` 的 `SMARTAgentDecoder`（海事无地图）。

#### 数据与加载
- 测试集 DataLoader 默认不打乱，顺序遍历样本：
```85:93:/home/mahexing/SMART-main/smart/datamodules/scalable_datamodule.py
def val_dataloader(self):
    return DataLoader(self.val_dataset, batch_size=self.val_batch_size, shuffle=False,
                      num_workers=self.num_workers, pin_memory=self.pin_memory,
                      persistent_workers=self.persistent_workers)

def test_dataloader(self):
    return DataLoader(self.test_dataset, batch_size=self.test_batch_size, shuffle=False,
                      num_workers=self.num_workers, pin_memory=self.pin_memory,
                      persistent_workers=self.persistent_workers)
```
- 滑窗导出默认 stride 极小（常见为 1），相邻样本高度重叠：
```205:209:/home/mahexing/SMART-main/pipeline/export_windows.py
ap.add_argument("--stride", type=int, default=1)
```

#### 可视化流程
- 当前按 DataLoader 顺序取前 5 个 batch 进行渲染：
```511:523:/home/mahexing/SMART-main/visualize_folium.py
with torch.no_grad():
    for idx, batch in enumerate(test_loader):
        if idx >= num_scenes:
            break
        # 移动到设备
        batch = batch.to(device)
        # 模型预测
        output = model(batch)
        prediction = output.get('cls_pred', None)
```
- 地图展示基于相对坐标（以 T_h-1 为原点），并近似转换到经纬度；已具备轴交换/翻转的自动与手动控制。

#### 问题复盘与根因
- 五个 HTML “看起来一样”的直接原因：
  - 测试集顺序遍历；前 5 个样本通常来自同一原始场景的相邻滑窗。
  - 导出 stride=1（或很小）导致窗口极度重叠，GT 轨迹几乎相同。
- 这更像是“取样策略问题”，不是模型或可视化绘制逻辑错误。

#### 方案A（等间距抽样）修改指南
目标：不再顺序取前 5 个滑窗，而是从整个测试集按等间距抽取 5 个样本进行可视化。

- 修改1：按数据集长度计算可视化数量
将
```python
num_scenes = min(5, len(test_loader))
```
替换为
```python
num_scenes = min(5, len(datamodule.test_dataset))
```

- 修改2：用等间距索引替换 DataLoader 顺序遍历
用以下循环替换原 511–535 行（保持相同缩进）：
```python
with torch.no_grad():
    num_total = len(datamodule.test_dataset)
    if num_total == 0:
        print("\n❌ 错误: 测试集为空")
        return

    num_scenes = min(5, num_total)
    indices = np.linspace(0, num_total - 1, num=num_scenes, dtype=int)

    for out_idx, ds_idx in enumerate(indices):
        sample = datamodule.test_dataset[ds_idx].to(device)

        # 可选：模型前向（当前可视化主要绘制GT）
        output = model(sample)
        prediction = output.get('cls_pred', None)

        # 可选：打印来源核对是否为不同样本
        file_idx, sample_idx = datamodule.test_dataset._sample_indices[ds_idx]
        src_file = os.path.basename(datamodule.test_dataset._file_paths[file_idx])
        print(f"  [DEBUG] scene_id={out_idx}, ds_idx={ds_idx}, src={src_file}, sample_idx={sample_idx}")

        scene_center_lat = center_lat + (out_idx * 0.05)
        scene_center_lon = center_lon + (out_idx * 0.1)

        save_path = os.path.join(output_dir, f'scene_{out_idx:03d}.html')
        create_map_visualization(sample, prediction, save_path,
                                 scene_id=out_idx,
                                 center_lat=scene_center_lat,
                                 center_lon=scene_center_lon,
                                 norm_stats=norm_stats)
```

注：你当前处于只读模式，上述为“建议的代码编辑”，请手动粘贴到 `visualize_folium.py`。

#### 快速验证清单
- 运行可视化后，查看控制台 `[DEBUG]` 打印，确认 5 个 `src`/`sample_idx` 不同。
- 打开 5 个 HTML，轨迹应明显不同；中心位置也按 out_idx 偏移。
- 若仍相似，考虑增大导出 stride（需重导数据，影响面大）或改为随机抽样。

#### 后续工作建议
- 方案B：在可视化阶段随机选取测试集样本，或分布式分桶抽样（按来源文件分散）。
- 方案C：从源头增大导出 `--stride`（如 5 或更高），减少滑窗重叠（需重导）。
- 补充一个 CLI 参数切换抽样策略（顺序/随机/等间距），提升脚本通用性。

- 已定位“5个场景几乎相同”的根因：测试集顺序遍历 + 滑窗高重叠（stride=1）。
- 提供了“方案A 等间距抽样”的具体修改位置与代码，支持立即得到差异化场景可视化。

### 可视化轨迹落陆地问题排查与修复

#### 问题现象
- `visualize_folium.py` 生成的交互式地图中，部分或全部船舶轨迹出现在陆地上。

#### 根因定位
- 经排查，核心问题在于**坐标系误用**：
  1.  **坐标系不匹配**: 数据样本 (`.pt`) 中的坐标是**局部坐标系**，即每个滑窗都以其参考帧（`T_h-1`时刻的参考船）为原点，并旋转到以该船朝向为X轴。
  2.  **错误的可视化映射**: `visualize_folium.py` 此前直接将这些“局部/已旋转”的米制坐标当作“全局东-北向”的偏移量。
  3.  **错误的锚点**: 脚本使用整个场景的起点经纬度（`origin_lat/lon`）或一个固定的默认中心作为所有窗口的地理锚点，而没有使用每个窗口参考帧的真实经纬度。

- 这个组合导致了两个关键的转换步骤缺失：
  - **“旋回”操作**: 将局部坐标系通过参考帧的朝向角 (`ref_theta`) 旋回到全局的东-北坐标系。
  - **“锚点”对齐**: 使用每个窗口参考帧的真实经纬度 (`ref_lat`, `ref_lon`) 作为米制转经纬度的基准点。

#### 已完成的修复（可视化侧）
- `visualize_folium.py` 已完成改造，具备了正确的坐标转换能力：
  - 增加了环境变量开关 `FOLIUM_USE_REF_ANCHOR` 用于激活新逻辑。
  - 开启后，脚本会尝试从每个数据样本中读取 `scene_info` 字典，获取该窗口的 `ref_lat`, `ref_lon`, `ref_theta`。
  - 在绘制历史点和未来点时，会执行正确的**“旋回+锚点”**映射，将局部坐标还原到真实的地理位置。

#### 下一步行动
- **数据侧待办**: 当前数据样本中尚未包含 `scene_info` 信息。
  - 需要修改预处理脚本 `pipeline/maritime_scene_preprocessor.py`。
  - 在 `create_hetero_data_for_window` 函数中，计算并存入每个窗口参考帧的真实经纬度与朝向角 (`ref_lat`, `ref_lon`, `ref_theta`) 到 `data.scene_info` 字典中。
  - 完成后，重新导出少量测试数据即可完成验证闭环。


### 可视化轨迹落陆地问题修复进展 (10-27)

#### 问题诊断与结论
- **已确认根因**: `visualize_folium.py` 生成的轨迹之所以出现在陆地上，是因为**数据样本中缺少每个滑窗独立的地理锚点信息**。
- **具体原因**: 可视化脚本在将局部坐标（以参考船为原点）转换回真实地理坐标时，需要每个窗口（滑窗样本）的参考帧在其原始场景中的真实经纬度 (`ref_lat`, `ref_lon`) 和朝向 (`ref_theta`)。由于预处理脚本并未提供这些信息，可视化脚本只能回退到使用一个固定的、全局的场景起点作为所有窗口的锚点，且无法进行正确的“旋回”操作，从而导致了坐标映射错误。
- **与Waymo对比**: Waymo 数据集的可视化通常在全局米制坐标系的 BEV (鸟瞰图) 上进行，不直接映射到经纬度地理底图，因此在其标准流程中无需在每个样本里携带地理锚点。海事场景的 folium 可视化需求则必须补上这一环。

#### 已完成的修复
1.  **数据预处理增强**:
    - 已修改 `pipeline/maritime_scene_preprocessor.py`。
    - 在 `create_hetero_data_for_window` 函数中，**新增了计算逻辑**：根据场景的全局原点 (`origin_lat/lon`) 和窗口参考帧的米制偏移 (`x_ref/y_ref`)，反推出参考帧的真实经纬度 (`ref_lat/ref_lon`)。
    - **已将 `ref_lat`, `ref_lon`, `ref_theta` (弧度) 存入每个数据样本的 `data.scene_info` 字典中**。

2.  **可视化逻辑修正**:
    - 检查并确认 `visualize_folium.py` 中用于读取 `scene_info` 并执行“旋回+锚点”的逻辑已存在，并通过 `FOLIUM_USE_REF_ANCHOR=1` 环境变量激活。
    - 修复了 `visualize_folium.py` 中一个**重复创建 `folium.Map` 对象**的小问题，避免了正确的锚点被默认中心覆盖。

#### 下一步行动
- **重新导出数据**: 使用更新后的预处理脚本，通过 `pipeline/export_windows.py` 重新生成测试集（或其他需要可视化的数据集），确保新的 `.pt` 文件都包含 `scene_info`。
- **验证可视化**:
  - 运行 `visualize_folium.py` 时，**必须设置环境变量** `FOLIUM_USE_REF_ANCHOR=1`。
  - 检查控制台输出，应看到 `[INFO] 使用窗口参考帧作为地图锚点...` 的日志。
  - 最终生成的 HTML 地图上，轨迹应正确显示在海域内。

### 数据重导与可视化验证结果（10-28）

- **数据路径（最新）**: `data/maritime_windows_refanchor`
  - 依据 `export_stats.json` 最新修改时间与最新 `.pt` 文件确认。

- **导出统计概览**（来自 `data/maritime_windows_refanchor/export_stats.json`）
  - **train**: num_scenes=12376, num_shards=28, num_samples=14314
  - **val**: num_scenes=1547, num_shards=4, num_samples=1794
  - **test**: num_scenes=1547, num_shards=4, num_samples=1796

- **结构/数值体检结果**（抽样 `train/val` 分片首样本）
  - **形状**: `agent.x=[N,21,8]`、`target_xy=[N,16,2]`，与 5 历史 + 16 未来一致。
  - **局部坐标对零**: 参考船在 T_h-1（index=4）满足 `x≈0,y≈0,theta≈0` → 局部系构建正确。
  - **速度/加速度**: 平均速度约 3.4–3.7 m/s（6.7–7.2 节），平均加速度 ~0.01 m/s²，符合港区常识范围。
  - **角度范围**: `theta∈[-π, π]`，wrap 正确；掩码形状与边关系正常。

- **Folium 可视化验证（FOLIUM_USE_REF_ANCHOR=1）**
  - 日志出现：`[INFO] 使用窗口参考帧作为地图锚点: (...), theta=...°`，说明 `scene_info` 已被读取并启用。
  - 生成 5 个 HTML，轨迹显著不同（等间距抽样生效），地图边界落在沪附近（约 31.28–31.39N, 121.50–121.61E）。
  - 自动轴推断在不同样本给出不同组合（正常现象）。
  - 备注：诊断打印中“当前锚点”一行仍显示默认中心（30,122），为打印变量使用不当所致；实际绘制已使用 `anchor_lat/lon`，不影响结果。

- **结论**
  - 数据重导已完成，`scene_info`（`ref_lat/ref_lon/ref_theta`）写入生效。
  - 可视化“落陆地/方向”问题在启用参考锚点与旋回后得到修复；取样相似性通过等间距抽样得到改善。

- **后续动作建议**
  - 运行评估闭环（示例）：
    - `python eval_test.py --config configs/train/train_maritime.yaml --pretrain_ckpt logs/maritime_checkpoints/epoch=09.ckpt`
  - 继续人工复核 `folium_maps/index.html` 多个场景的落点与朝向；若个别场景方向仍不理想，可临时使用 `FOLIUM_FORCE_TRANSFORM` 试探最优轴设置。
  - （可选）微调日志打印：在 `visualize_folium.py` 的证据打印中改为输出 `anchor_lat/anchor_lon` 以避免误导。

### 评估结果（10-28）

- **评估设置**
  - 配置: `configs/train/train_maritime.yaml`
  - 检查点: `logs/maritime_checkpoints/epoch=09.ckpt`
  - 数据集: test（脚本指标前缀为 `val_`）

- **数据规模**
  - test 共 1796 个样本（来自 4 个文件），与导出统计一致。

- **指标**
  - `val_cls_acc`: 0.5158
  - `val_loss`: 3.1064

- **结论**
  - 明显优于随机（2048 类的随机交叉熵≈ln(2048)=7.62），与此前约 51.2% 接近；迁移到新数据链路后性能稳定。

- **性能与日志**
  - 评估速率≈2.72 it/s（1796 batch ≈ 11 分钟）；如需提速可将 `Dataset.num_workers` 提高至 8–16（评估阶段）。
  - 退出时的 NCCL 进程组销毁警告可忽略；如需消除可在自定义流程结束显式销毁进程组。

### 短训与权重评估（10-28）

- **训练设置**
  - 配置: `configs/train/train_maritime.yaml`
  - 输出目录: `logs/maritime_refanchor_ckpts`
  - 训练时长: ≈24–25 分钟/epoch（A40）

- **3轮短训结果（从零开始）**
  - `val_cls_acc`: 0.258 → 0.371（Epoch 0 → 2）
  - `val_loss`: 6.95 → 5.88（持续下降）
  - 结论：收敛方向正常，仍处于“热身期”，与既有模型（≈0.515）有差距；建议延长到 10–15 轮，或用 `epoch=09.ckpt` 热启动微调 5–8 轮更快对齐。

- **评估当前权重（epoch=02）**
  - `val_cls_acc`: 0.3725
  - `val_loss`: 5.8772
  - 吞吐: ≈12.78 it/s（1796 batch ≈ 2 分 20 秒）
  - 结论：与训练日志一致，指标稳定。

### 自动海陆判定尝试与结论（10-28）

- **目的**：自动判断可视化轨迹是否“落陆地”，用于批量质检。

- **尝试与结果**
  1. 使用 GeoPandas + Fiona 读取 `naturalearth_lowres`：环境报错（`fiona.path` 不兼容，且 GeoPandas 1.0 起移除了内置 datasets）。
     - 处理：改用 `pyogrio` 后端，并直接从 Natural Earth 官方 URL 读取矢量 ZIP。
  2. 用 NE 1:50m “Land” 多边形判“陆地”：外高桥港池/河口在该尺度被合并为陆地，导致陆地比例≈99%。
  3. 用 NE 1:10m “Ocean” 多边形判“水域”：港池/河口仍多未覆盖，陆地比例依旧≈98%。

- **结论与当前策略**
  - NE 数据在港区/河口尺度不适合海陆二分类质检，易将港池/航道误判为陆地。
  - 当前采用**人工目测**方式复核：
    - 运行：`FOLIUM_USE_REF_ANCHOR=1 python visualize_folium.py`
    - 如个别方向不一致，可用 `FOLIUM_FORCE_TRANSFORM` 试探（例如 `"1,0,0"` 交换XY）。
  - 后续可选：换用更精细水域数据（如 GSHHG 高分海岸线或 OSM water polygons），或做局部裁剪与缓冲后再做自动判定。

### 可视化稳定性与多样性改进（10-29）

#### 1) scene_000 偶发“落陆地”问题已消除
- 现象：五个场景中仅 `scene_000` 偶发落在陆地，其余正常。
- 根因：在靠岸/河口等复杂地带，“自动轴推断”可能偶发误判（交换/翻转导致镜像到陆侧）。
- 操作与结论：启用窗口参考锚点+旋回，并禁用自动轴推断后问题消失。
  - 运行示例（未改代码时临时强制）：
    ```bash
    FOLIUM_USE_REF_ANCHOR=1 FOLIUM_FORCE_TRANSFORM=0,0,0 python visualize_folium.py
    ```
  - 建议的“永久化”行为：当 `FOLIUM_USE_REF_ANCHOR=1` 时默认禁用自动轴推断，仅在显式 `FOLIUM_FORCE_TRANSFORM` 时才生效（避免误判）。
  - 代码编辑指引（`visualize_folium.py` 中轴变换推断位置，约 276–284 行）：
    - 将“自动推断+可强制”改为“use_ref_anchor 时默认关闭自动推断，可强制覆盖；否则保留原自动推断”。
    - 可引入环境变量 `FOLIUM_DISABLE_AUTO_AXIS`（默认 `1`）控制该默认行为。

#### 2) “五个场景看起来相似”的改进取样
- 根因：数据导出滑窗高度重叠，且 DataLoader 顺序/等间距索引仍可能聚焦同一来源文件/同一水域主航道。
- 解决：在可视化阶段按“来源文件分桶”抽样，优先跨文件分散；每文件内取中位或随机一个样本。
- 建议替换 `visualize_folium.py` 生成循环前的索引计算，逻辑如下（伪代码要点）：
  - 从 `datamodule.test_dataset._sample_indices` 取 `(file_idx, sample_idx)`，将同 `file_idx` 的样本分桶；
  - 在唯一文件集合上等间距选 `num_scenes` 个文件；
  - 每个被选文件内取“中位样本”（或随机/首末），并打印 `[DEBUG]` 确认来自不同文件。
- 备选：
  - 随机抽样：`np.random.choice(num_total, size=num_scenes, replace=False)`；
  - 源头降低相似：导出时将 `--stride` 增大为 5/10（需重导）。

#### 3) “强保障”选项：接入水域守护（Water-Guard）（可选）
- 目标：在 8 种轴组合（是否交换XY×翻转X×翻转Y）中，自动选择“轨迹点落水比例最高”的组合；必要时可过滤陆地点。
- 要点：
  - 需要较精细的矢量数据：优先 OSM water polygons（区域裁剪）、或 GSHHG 高分海岸线；
  - 运行参数示例：
    ```bash
    FOLIUM_USE_REF_ANCHOR=1 \
    FOLIUM_WATER_GUARD=1 \
    FOLIUM_WATER_DATA=data/water_mask/osm_water.shp \
    FOLIUM_WATER_MODE=water \
    python visualize_folium.py
    ```
  - 说明：`FOLIUM_WATER_MODE=water` 表示提供的是“水域多边形”；若提供“陆地多边形”，则设为 `land`。
  - 建议：如仍有极个别点踩陆，可开启点级过滤（可用环境变量开关控制）。

#### 4) 验证清单
- 运行可视化：`FOLIUM_USE_REF_ANCHOR=1 python visualize_folium.py`
- 确认日志：
  - `[INFO] 使用窗口参考帧作为地图锚点: (...), theta=...°`；
  - `轴变换(...): swap_xy=..., flip_x=..., flip_y=...`（use_ref_anchor 场景应为默认关闭自动推断或被显式强制）。
- 打开 `folium_maps/*.html`：
  - 轨迹应稳定落在水域；
  - 五个场景在“分桶抽样”后形态明显不同；
  - 地图边界在沪附近合理范围；
  - 若启用 Water-Guard，日志应出现水域掩模加载成功与 `water_ratio=...` 的评分信息。

#### 5) 小结
- “落陆地”问题：通过“参考锚点+旋回+默认禁用自动轴推断（可强制覆盖）”已稳定解决；
- “场景相似”问题：通过“按来源文件分桶抽样/随机抽样/增大导出 stride”可显著缓解；
- 若需更强保障，可叠加 Water-Guard（基于水域/陆地矢量掩模）自动选择轴组合并可过滤陆地点。

### 可视化与抽样改造落地与验证（10-29 更新）

#### 改动已落地
- use_ref_anchor 时默认禁用自动轴推断（可强制覆盖/可配置）：
```276:289:/home/mahexing/SMART-main/visualize_folium.py
    # === 轴变换策略 ===
    forced, fswap, fflipx, fflipy = _parse_axis_override()
    _disable_default = '1' if use_ref_anchor else '0'
    disable_auto_axis = os.getenv('FOLIUM_DISABLE_AUTO_AXIS', _disable_default) == '1'

    if forced:
        swap_xy, flip_x, flip_y = fswap, fflipx, fflipy
        print(f"    [DEBUG] 轴变换(强制): swap_xy={swap_xy}, flip_x={flip_x}, flip_y={flip_y}")
    elif disable_auto_axis:
        swap_xy, flip_x, flip_y = False, False, False
        print(f"    [DEBUG] 轴变换(禁用自动): swap_xy={swap_xy}, flip_x={flip_x}, flip_y={flip_y}")
    else:
        swap_xy, flip_x, flip_y = _infer_axis_flip(positions, headings, num_historical, norm_stats)
        print(f"    [DEBUG] 轴变换(自动): swap_xy={swap_xy}, flip_x={flip_x}, flip_y={flip_y}")
```

- 分桶抽样（跨文件分散，桶内可选 median/random/first/last，默认 median）：
```502:536:/home/mahexing/SMART-main/visualize_folium.py
    # 构建 file_idx -> [ds_idx...] 桶
    file_to_ds_indices = {}
    for ds_idx, (file_idx, sample_idx) in enumerate(ds._sample_indices):
        file_to_ds_indices.setdefault(file_idx, []).append(ds_idx)

    unique_file_indices = sorted(file_to_ds_indices.keys())
    num_scenes = min(5, len(unique_file_indices))  # 以文件桶数量为上限

    # 等间距选择文件桶
    file_sel = np.linspace(0, len(unique_file_indices) - 1, num=num_scenes, dtype=int)
    chosen_files = [unique_file_indices[i] for i in file_sel]

    # 桶内选择策略：median|random|first|last（默认：median）
    pick_mode = os.getenv('FOLIUM_BUCKET_PICK', 'median').strip().lower()
    def _pick_from_bucket(bucket):
        if not bucket:
            return None
        if pick_mode == 'random':
            return int(bucket[np.random.randint(0, len(bucket))])
        if pick_mode == 'first':
            return int(bucket[0])
        if pick_mode == 'last':
            return int(bucket[-1])
        return int(bucket[len(bucket) // 2])

    indices = []
    for fidx in chosen_files:
        bucket = file_to_ds_indices.get(fidx, [])
        ds_idx = _pick_from_bucket(bucket)
        if ds_idx is None:
            continue
        src_file = os.path.basename(ds._file_paths[fidx])
        sample_idx = ds._sample_indices[ds_idx][1]
        print(f"   [DEBUG] 分桶抽样: file_idx={fidx}, src={src_file}, bucket_size={len(bucket)}, pick={pick_mode}, ds_idx={ds_idx}, sample_idx={sample_idx}")
        indices.append(ds_idx)
```

#### 运行验证（10-29）
- 命令：`FOLIUM_USE_REF_ANCHOR=1 python visualize_folium.py`
- 日志摘录：
  - 分桶抽样：4 条 `[DEBUG] 分桶抽样]`，来源 `shard_00000.pt` ~ `shard_00003.pt`，每桶容量/选择索引打印正确。
  - 参考锚点：每场景打印 `[INFO] 使用窗口参考帧作为地图锚点: (ref_lat, ref_lon), theta=…°`。
  - 轴策略：均打印 `[DEBUG] 轴变换(禁用自动): swap_xy=False, flip_x=False, flip_y=False`。
  - 地图范围：`[DEBUG] 地图边界` 均位于约 31.28–31.60N、121.50–121.60E，合理。
  - 产出：成功生成 4 个 HTML 与索引页（与 test 分片数一致）。

#### 使用说明（补充）
- 桶内随机：`FOLIUM_BUCKET_PICK=random FOLIUM_USE_REF_ANCHOR=1 python visualize_folium.py`
- 临时开启自动轴推断：`FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=0 python visualize_folium.py`
- 强制覆盖轴：`FOLIUM_FORCE_TRANSFORM=1,0,0 python visualize_folium.py`

#### 小结
- 视觉“落陆地/方向”问题：在“参考锚点+旋回+默认禁用自动轴推断（可强制覆盖）”策略下已稳定解决。
- “场景相似”问题：分桶抽样已显著提升多样性；可按需开启桶内随机进一步增强差异性。


### 预测可视化与模型推理修复（10-29 晚）

- 目标与产出
  - 新增 `visualize_predictions_folium.py`：同图对比“历史/GT未来/模型预测”。
  - 每艘船使用一致的专属颜色，线型区分语义：
    - 历史：同色实线小点
    - GT未来：同色短虚线（dash 6,4）
    - 预测：同色长虚线（dash 8,5）
  - 参考锚点与旋回默认启用（`FOLIUM_USE_REF_ANCHOR=1`），自动轴推断默认禁用（可强制覆盖）。

- 关键代码修复（`smart/modules/agent_decoder.py`）
  - 动态 `shift`：从 token 库推断步长，替换所有硬编码 `6/5` 为 `self.shift + 1 / self.shift`。
  - 无地图安全：仅在 `('x_pt' in map_enc) and (edge_index_pl2a.shape[1] > 0)` 时执行 `pt2a` 交互，避免 `KeyError: 'x_pt'`。
  - 维度一致：预测相对位移仅与 `pos_a[..., :2]` 相加；写回时也仅更新 `:2`，修复 “2 vs 8” 维度不匹配。
  - 无 `position` 兼容：推理时若无 `data['agent']['position']`，用 `agent.x` 的形状推步数，GT 退化为 `agent.x[..., :2]`。

- 可视化脚本修正（`visualize_predictions_folium.py`）
  - 预测折线补齐 `dash_array="8,5"` 且 `.add_to(m)`，确保“同色长虚线”正确显示。
  - 分桶抽样：跨来源文件分散样本，桶内可 `median|random|first|last`（默认 `median`）。

- 运行与结果
  - 命令示例：
    ```bash
    FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 \
    python visualize_predictions_folium.py \
      --config configs/train/train_maritime.yaml \
      --pretrain_ckpt logs/maritime_checkpoints/epoch=09.ckpt \
      --split test --num_scenes 5
    ```
  - 输出目录：`folium_pred_maps/scene_*.html` 与 `index.html`。
  - 本次 test 有 4 个分片 → 实际生成 4 个场景（预期行为）。
  - 日志摘录（示例）：
    - `[INFO] 使用窗口参考锚点: (...), theta=...°`
    - `[DEBUG] 轴变换(禁用自动): swap_xy=False, flip_x=False, flip_y=False`
    - `✅ 地图保存: folium_pred_maps/scene_XXX.html`

- 验证清单
  - 打开 `folium_pred_maps/index.html`：
    - 同色的历史/GT/预测三段应连贯且语义清晰（实线/短虚线/长虚线）。
    - 轨迹落水域且方向合理（参考锚点+旋回已启用）。
    - 4 个场景来源分散（分桶抽样）。

- 备注与后续
  - 若需进一步量化，可在脚本中顺手输出抽样场景的 ADE/FDE。
  - 如个别场景方向异常，可临时强制轴：`FOLIUM_FORCE_TRANSFORM=1,0,0`（交换XY）或 `0,1,0`/`0,0,1`（翻转）。
  - `folium_maps/*.html` 为旧版仅 GT 可视化；`folium_pred_maps/*.html` 才包含预测。


### 预测误差量化与推理错位诊断（10-29 晚增补）

- 新增度量与修复
  - 在 `visualize_predictions_folium.py` 中新增 ADE/FDE 指标输出，并补充诊断打印：
    - PathLen(mean): 逐步位移和（GT/Pred）
    - EndDisp(mean): 首末点位移模长（GT/Pred）
    - DirCos(mean): 逐步方向余弦相似度
  - 修复 NumPy “or” 布尔歧义导致的异常（使用显式 None 回退逻辑）。
  - 修复 `MaritimeTargetBuilder` 的 token 读取：改为从 `traj` 字典读取并优先 `ship`（无则回退首个键），避免随机索引退化。

- 实测结果（test，分桶抽样共4场景，示例）
  - Scene 0: ADE=930.21 m, FDE=1661.23 m；PathLen(mean) GT=1661.4 m, Pred=807.5 m；EndDisp(mean) GT=1397.1 m, Pred=394.9 m；DirCos=0.048
  - Scene 1: ADE=985.55 m, FDE=1735.76 m；PathLen(mean) GT=1701.7 m, Pred=814.9 m；EndDisp(mean) GT=1482.6 m, Pred=443.3 m；DirCos=0.057
  - Scene 2: ADE=958.78 m, FDE=1632.95 m；PathLen(mean) GT=1612.0 m, Pred=805.9 m；EndDisp(mean) GT=1584.8 m, Pred=378.9 m；DirCos=0.163
  - Scene 3: ADE=801.42 m, FDE=1444.33 m；PathLen(mean) GT=1378.1 m, Pred=802.2 m；EndDisp(mean) GT=1364.6 m, Pred=349.4 m；DirCos=0.141

- 结论
  - 预测“走不远、方向不对”：Pred 路程≈800 m 仅为 GT≈1.4–1.7 km 的约一半；末端位移明显偏小；方向一致性低（DirCos≈0.05–0.16）。
  - 非单纯“收敛不够”，更像推理阶段的“时间/角度索引错位”引发的系统性偏差。

- 高概率根因（按影响度）
  1. 解码器 shift 错位：`SMARTAgentDecoder` 推理阶段使用了 `// self.shift` 的整除索引来定位参考帧、旋转角和写入位置；若 `self.shift != 1`（可能从 token_all 的 shape 动态推断得到），会造成大范围时间错位，导致位移丢失与方向错误。
  2. 角度索引偏移：存在以“上一帧角”进行旋转的写法，进一步拉低方向一致性。
  3. 码本与时间步长不一致：如仍使用非海事/非30s步长的 token_all 或 token 库，会引入运动尺度偏差（本次已将 transform 侧读取修正到 `traj['ship']`）。

- 证据代码位置（时间/角索引相关片段）
```419:506:/home/mahexing/SMART-main/smart/modules/agent_decoder.py
for t in range(self.num_recurrent_steps_val // self.shift):
    ...
    theta = head_a[:, (self.num_historical_steps - 1) // self.shift - 1 + t]
    ...
    pos_a[:, (self.num_historical_steps - 1) // self.shift + t, :2] = agent_pred_rel[:, -1, ...].clone().mean(dim=1)
```

- 建议修复路径（分步落地）
  - A) 强制海事 shift=1：在 `SMARTAgentDecoder.__init__` 中检测 `dataset=='maritime'` 时固定 `self.shift = 1`，忽略 token_all 的动态推断，避免整除索引错位。
  - B) 重写推理时间索引为“真实时间步”：
    - 统一定义 `hist_idx_end = self.num_historical_steps - 1`。
    - 使用 `hist_idx_end + t` 替代所有 `// self.shift` 的整除索引，覆盖：`inference_mask` 构造、选取旋转角 `theta`、写回 `pos_a/head_a`、与 `pred_traj` 切片区间。
    - 处理“余步”：当 `num_future_steps` 不是整块长度时，补齐剩余步，保证恰好预测 16 步。
  - C) 统一码本与30s步长：确保使用海事 token 库 `traj['ship']`（或等价的30s步长库），避免跨域/跨步长导致的速度/位移尺度偏差。
  - D) 修复后复评：期望 `PathLen(Pred) ≈ PathLen(GT)`、`DirCos > 0.6`，ADE/FDE 显著下降（常见>50%）。

- 后续可选增强
  - 在 token 预测之后叠加“残差回归头”（2–3层MLP）对每步偏移做细化，常能进一步降低 FDE。
  - 在预测可视化 HTML 顶部叠加场景级指标信息框。

- 复现实验命令（保持参考锚点与禁用自动轴，以确保预测/GT同系对比）
```bash
FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 \
python visualize_predictions_folium.py \
  --config configs/train/train_maritime.yaml \
  --pretrain_ckpt logs/maritime_checkpoints/epoch=09.ckpt \
  --split test --num_scenes 5
```


### 推理旋转/索引/偏置修复与验证（10-30）

- 目标：修复预测阶段“方向不一致/净位移偏小”问题，提升 DirCos、降低 ADE/FDE。

- 已落地改动（模型推理侧）
  - 强制海事 `shift=1`：避免整除索引引发的时刻错位（`SMARTAgentDecoder.__init__`）。
  - 索引统一到真实时间步：用 `hist_idx_end = num_historical_steps-1`；读角/基点用 `hist_idx_end + t`，写回用 `hist_idx_end + 1 + t`。
  - 旋转角来源改为“位置差分角”：不再直接使用 `head_a`，而是用相邻两时刻位置差分 `atan2` 作为旋回角。
  - 旋转矩阵与训练侧一致：采用 R(theta) 形式（与 `transform_rel` 对齐）。
  - 预测写回朝向：用“位置差分角”写回下一时刻的 `head_a`，避免四角点顺序不一致带来的偏差。
  - Token 选择：由随机采样改为贪心 Top-1，提升方向与路径稳定性。
  - 可调偏置：新增环境变量 `DECODER_ROT_OFFSET_DEG`，可试探 0/±90/180° 常量偏置。

- 指标对比（test，分桶抽样4场景，代表性摘录）
  - 偏置=0°（修改前后对比）：
    - 修改前：DirCos≈0.01–0.15，ADE≈0.80–1.0 km，FDE≈1.44–1.80 km，EndDisp明显偏小；
    - 修改后（位置差分角+R(theta)+贪心）：DirCos≈0.21–0.42，ADE/FDE显著下降，EndDisp上升；
  - 偏置=+90°：DirCos中等（≈0.29–0.64），波动较大；
  - 偏置=−90°：整体偏弱且不稳定；
  - 偏置=180°（最佳）：
    - DirCos最高（单场景可达≈0.709，整体≈0.48–0.65）；
    - ADE/FDE最低（例如 ADE≈0.45–0.65 km，FDE≈0.80–1.05 km 量级）；
    - EndDisp(mean) 明显接近 GT（>1.0 km）。

- 结论
  - 方向问题的主因并非“模型能力不足”，而是“推理阶段的旋回参考/坐标系与码本模板定义存在固定偏角”。
  - 实验显示海事场景在 `DECODER_ROT_OFFSET_DEG=180` 时最稳定、指标最好，说明模板前进方向与位置差分角存在约 180° 的系统性差异。

- 决策与建议
  - 默认偏置：将海事默认偏置固定为 180°（仍可被 `DECODER_ROT_OFFSET_DEG` 覆盖），并在日志打印当前偏置角以便追踪。
  - 训练/推理一致性：建议训练前向也改用“位置差分角”构造 `head_vector_a`，再用现有权重微调 5–8 轮，预计 DirCos 进一步提升（>0.7）。
  - 可选增强：
    - 实现“自动偏置选择”（在 {0, ±90, 180} 中试算一步评分选最优）；
    - 在 token 预测后叠加轻量残差头细化每步位移，进一步降 FDE；
    - 按需保留 Water-Guard 以进一步稳健方向/落点。

- 运行要点（示例）
  - 固定偏置（覆盖默认）：
    ```bash
    FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 DECODER_ROT_OFFSET_DEG=180 \
    python visualize_predictions_folium.py \
      --config configs/train/train_maritime.yaml \
      --pretrain_ckpt logs/maritime_checkpoints/epoch=09.ckpt \
      --split test --num_scenes 4
    ```
  - 不指定 `DECODER_ROT_OFFSET_DEG` 时，推荐将海事默认值设为 180°（后续代码将固化）。

### 训练加速与多卡微调落地（10-30 下午）

#### 改动概览（已落地）
- 训练入口 `train.py`：
  - 启用 TF32、`cudnn.benchmark`（矩阵计算提速）。
  - 使用更稳妥的 DDP 设置：`find_unused_parameters=True`、`static_graph=False`，避免动态分支导致的反向断言。
  - 默认精度改为 `'16-mixed'`（AMP 混合精度，兼顾速度与稳定性）。
  - 保留可选 `torch.compile`（需 `USE_TORCH_COMPILE=1` 开启）。

```31:35:/home/mahexing/SMART-main/train.py
strategy = DDPStrategy(
    find_unused_parameters=True,
    gradient_as_bucket_view=True,
    static_graph=False
)
```

```59:70:/home/mahexing/SMART-main/train.py
trainer = pl.Trainer(
    accelerator=trainer_config.accelerator,
    devices=trainer_config.devices,
    strategy=strategy,
    accumulate_grad_batches=trainer_config.accumulate_grad_batches,
    num_nodes=trainer_config.num_nodes,
    callbacks=[model_checkpoint, lr_monitor],
    max_epochs=trainer_config.max_epochs,
    num_sanity_val_steps=0,
    gradient_clip_val=0.5,
    precision=getattr(trainer_config, 'precision', '16-mixed')
)
```

- 数据模块 `smart/datamodules/scalable_datamodule.py`：新增 `prefetch_factor`，在 `num_workers>0` 时启用，提升数据供给并行吞吐。

```21:31:/home/mahexing/SMART-main/smart/datamodules/scalable_datamodule.py
def __init__(self,
             root: str,
             train_batch_size: int,
             val_batch_size: int,
             test_batch_size: int,
             shuffle: bool = False,
             num_workers: int = 0,
             pin_memory: bool = True,
             persistent_workers: bool = True,
             prefetch_factor: int = 4,
             train_raw_dir: Optional[str] = None,
             ...)
```

```82:92:/home/mahexing/SMART-main/smart/datamodules/scalable_datamodule.py
def train_dataloader(self):
    loader_kwargs = dict(
        batch_size=self.train_batch_size,
        shuffle=self.shuffle,
        num_workers=self.num_workers,
        pin_memory=self.pin_memory,
        persistent_workers=self.persistent_workers,
    )
    if self.num_workers > 0:
        loader_kwargs['prefetch_factor'] = self.prefetch_factor
    return DataLoader(self.train_dataset, **loader_kwargs)
```

- 配置 `configs/train/train_maritime.yaml`：
  - 多卡训练 `devices: 4`，混合精度 `precision: 16-mixed`。
  - 强化数据供给：`num_workers: 16`、`prefetch_factor: 4`、`pin_memory/persistent_workers: true`。
  - 批量策略：保持 `train/val/test_batch_size: 1`（避免 PyG 批内拼接因变长维度报错），用 `accumulate_grad_batches: 4` 放大有效 batch（等效全局 batch≈ 1×4卡×4累计=16）。

```11:20:/home/mahexing/SMART-main/configs/train/train_maritime.yaml
Dataset:
  root: null
  train_batch_size: 1
  val_batch_size: 1
  test_batch_size: 1
  shuffle: True
  num_workers: 16
  pin_memory: True
  persistent_workers: True
  prefetch_factor: 4
```

```34:43:/home/mahexing/SMART-main/configs/train/train_maritime.yaml
Trainer:
  accelerator: "gpu"
  devices: 4
  max_epochs: 5
  save_ckpt_path: "logs/maritime_checkpoints"
  num_nodes: 1
  mode: null
  ckpt_path: null
  precision: 16-mixed
  accumulate_grad_batches: 4
```

#### 推理偏置（已固化为 0°，仍可被环境变量覆盖）
```505:507:/home/mahexing/SMART-main/smart/modules/agent_decoder.py
default_deg = '0' if (isinstance(self.dataset, str) and self.dataset.lower() == 'maritime') else '0'
offset = math.radians(float(os.getenv('DECODER_ROT_OFFSET_DEG', default_deg)))
```

#### 训练与评估结果
- 多卡训练成功（日志显示 `MEMBER: 1/4` / `Starting with 4 processes`）。
- 5 轮微调后（`epoch=04.ckpt`）：
  - `val_cls_acc`: 0.3723 → 0.3944（↑+0.0221，约+5.9%）
  - `val_loss`: 5.8771 → 5.4207（↓-0.4564，约-7.8%）

#### 预测可视化（test, 分桶随机，偏置0°，代表性4场）
- Scene 0/1/2/3（节选）：
  - DirCos≈0.518 / 0.644 / 0.633 / 0.573
  - ADE≈588/451/478/650 m；FDE≈1022/841/827/1141 m
- 方向一致性与末端位移相对微调前更稳，整体误差下降。

#### 效能与稳定性
- 之前 GPU 利用率偏低（约 10–15%）：主因是数据供给与 batch 设置。
- 现已通过多卡、AMP、`num_workers=16`、`prefetch_factor=4`、梯度累计等手段显著提升吞吐；
  批量保持 1 避免 PyG 批内变长拼接报错（`Sizes of tensors must match ...`）。
- DDP 改为 `find_unused_parameters=True`、`static_graph=False`，避免动态分支导致的反向钩子断言错误。

#### 后续建议
- 继续小幅微调 5–10 轮观察 DirCos/ADE/FDE 是否进一步收敛。
- 可选：实现“自动偏置选择”（在 {0,±90,180} 中择优）；在 token 预测后叠加轻量残差回归头细化位移（常能进一步降 FDE）。


### 近期进展与结论（10-31）

#### 训练与分类评估
- 严格续训至 25 轮（从 `epoch=04` → `epoch=24`）。评估日志：`val_cls_acc ≈ 0.4627`、`val_loss ≈ 3.7278`，较 15 轮时（`≈0.460`）略有提升。

#### 可视化与脚本改动（已落地）
- 连线修复：补上历史最后点 → 未来/预测首点的连线，消除 T_h-1 → T_h 断裂。
```259:275:/home/mahexing/SMART-main/visualize_predictions_folium.py
        hist_last_coord = hist_coords[-1] if len(hist_coords) > 0 else None
        ...
        if hist_last_coord is not None and len(fut_coords) > 0:
            fut_coords = [hist_last_coord] + fut_coords
```
```293:303:/home/mahexing/SMART-main/visualize_predictions_folium.py
        if hist_last_coord is not None and len(pred_coords) > 0:
            pred_coords = [hist_last_coord] + pred_coords
```
- 批评测开关：新增 `--sample_mode {bucket|uniform|random}` 与 `--no_save_map`，支持从全量均匀/随机抽取大量样本，仅打印 ADE/FDE/DirCos 指标，避免生成 HTML。
```339:349:/home/mahexing/SMART-main/visualize_predictions_folium.py
    parser.add_argument('--sample_mode', type=str, default=os.getenv('FOLIUM_SAMPLE_MODE', 'bucket'),
                        choices=['bucket', 'uniform', 'random'])
    parser.add_argument('--no_save_map', action='store_true')
```
```91:115:/home/mahexing/SMART-main/visualize_predictions_folium.py
def _pick_indices_uniform(ds, num_scenes: int):
    ...
def _pick_indices_random(ds, num_scenes: int, seed: int = 0):
    ...
```
- 控制是否保存地图：
```144:152:/home/mahexing/SMART-main/visualize_predictions_folium.py
def _draw_scene_prediction_map(..., save_map: bool = True):
```
```312:314:/home/mahexing/SMART-main/visualize_predictions_folium.py
    if save_map:
        m.save(output_path)
        print(f"  ✅ 地图保存: {output_path}")
```

#### 偏置角（DECODER_ROT_OFFSET_DEG）阶段结论
- 在相同抽样与环境下，当前权重的 4 场景对比显示：0° 明显优于 ±90° 与以往记录的 180°，表现为更低 ADE/FDE 与更高 DirCos（示例均值：0° 的 DirCos≈0.55，180°≈0.36）。
- 建议暂以 0° 作为默认推理偏置；为稳妥，使用 1000 样本统一抽样进一步验证（见下）。

#### 1000 样本四角度批评测（确定最终默认偏置）
运行：
```bash
cd /home/mahexing/SMART-main
CKPT="$(ls -t logs/maritime_ft0deg_ckpts/*.ckpt | head -n1)"
for deg in 0 90 -90 180; do
  OUT="folium_pred_maps_off${deg}_1000"
  FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 FOLIUM_SAMPLE_MODE=uniform DECODER_ROT_OFFSET_DEG=$deg \
  python visualize_predictions_folium.py \
    --config configs/train/train_maritime.yaml \
    --pretrain_ckpt "$CKPT" \
    --split test --num_scenes 1000 \
    --output_dir "$OUT" --no_save_map | tee "metrics_off${deg}_1000.log"
done
```
汇总：
```bash
cd /home/mahexing/SMART-main
for deg in 0 90 -90 180; do
  printf "deg=%s  " "$deg"
  awk -F '[= m,]+' '/Scene .*ADE=/{ade+=$3; fde+=$5; n++} END{printf "ADE=%.2f m FDE=%.2f m  ", ade/n, fde/n}' metrics_off${deg}_1000.log
  awk -F ': ' '/DirCos/{d+=$NF; n++} END{printf "DirCos=%.3f\n", d/n}' metrics_off${deg}_1000.log
done
```
落地：
- 临时：推理/可视化命令前显式加 `DECODER_ROT_OFFSET_DEG=最佳角`；
- 长期：在 `~/.bashrc` 写入 `export DECODER_ROT_OFFSET_DEG=最佳角`。

#### OOM 规避（可选）
- 批量评测时如遇 `torch.load(..., device='cuda')` OOM：建议先在 CPU 加载检查点再 `model.to(cuda)`；或限制单卡、清理占用进程，必要时分批评测（如每次 500）。


### 评估脚本启用 ADE/FDE 与最新结果（11-03）

- 目的：在 Lightning 验证阶段直接统计 ADE/FDE，与分类精度共同报告，形成统一评估口径。

- 启用方法（`eval_test.py`）：在模型实例化后开启推理度量
```80:86:/home/mahexing/SMART-main/eval_test.py
print(f"\n🧠 加载模型...")
logger = Logging().log(level='INFO')
model = SMART(config.Model)
model.inference_token = True  # 启用推理度量（minADE/minFDE）
model.load_params_from_file(filename=args.pretrain_ckpt, logger=logger)
```

- 评估运行示例（test 集）：
```bash
cd /home/mahexing/SMART-main
python eval_test.py \
  --config configs/train/train_maritime.yaml \
  --pretrain_ckpt logs/maritime_ft0deg_ckpts/epoch=24.ckpt \
  --split test
```

- 指标来源（`SMART.validation_step` 在 `inference_token=True` 时记录 ADE/FDE）：
```199:226:/home/mahexing/SMART-main/smart/model/smart.py
self.log('val_cls_acc', self.TokenCls, prog_bar=True, on_step=False, on_epoch=True, batch_size=1, sync_dist=True)
self.log('val_loss', loss, prog_bar=True, on_step=False, on_epoch=True, batch_size=1, sync_dist=True)

if self.inference_token:
    pred = self.inference(data)
    valid_mask = data['agent']['valid_mask'][:, self.num_historical_steps:]
    pred_traj = pred['pred_traj']
    gt = pred['gt']
    eval_mask = data['agent']['valid_mask'][:, self.num_historical_steps-1]
    self.minADE.update(pred=pred_traj[eval_mask], target=gt[eval_mask], valid_mask=valid_mask[eval_mask])
    self.minFDE.update(pred=pred_traj[eval_mask], target=gt[eval_mask], valid_mask=valid_mask[eval_mask])
    self.log('val_minADE', self.minADE, prog_bar=True, on_step=False, on_epoch=True, batch_size=1)
    self.log('val_minFDE', self.minFDE, prog_bar=True, on_step=False, on_epoch=True, batch_size=1)
```

- 本次评估（25 轮模型，`epoch=24.ckpt`）四次运行结果（按给定顺序）：
  - 固定项：`val_cls_acc=0.5046`、`val_loss=3.2474`
  - Run#1：`val_minADE=656.8938 m`，`val_minFDE=1156.9500 m`
  - Run#2：`val_minADE=633.9706 m`，`val_minFDE=1121.9399 m`
  - Run#3：`val_minADE=629.0555 m`，`val_minFDE=1114.9036 m`
  - Run#4：`val_minADE=604.4144 m`，`val_minFDE=1079.6949 m`（最佳）

- 快速结论：
  - 指标随运行设置逐步改善，第 4 次最佳；相对第 1 次，ADE≈-8.0%，FDE≈-6.7%。
  - 该改进与推理旋转偏置（`DECODER_ROT_OFFSET_DEG`）等设置相关；需对齐“运行顺序 ⇄ 偏置角”映射后，固化为默认。

- 建议的后续动作：
  1) 确认四次运行对应的 `DECODER_ROT_OFFSET_DEG` 顺序，将最佳对应角度设为默认（临时可 `export DECODER_ROT_OFFSET_DEG=...`，长期可写入 `~/.bashrc` 或在模型代码中默认值固化）。
  2) 如需更稳健结论，使用 `visualize_predictions_folium.py --no_save_map --sample_mode uniform --num_scenes 1000` 做批量对比（可同时输出 DirCos）。
  3) 评估脚本两条路径并存：
     - 分类/KD口径：`eval_test.py`（Lightning validate，输出 `val_cls_acc/val_loss`，在开启 `inference_token` 后附带 `val_minADE/val_minFDE`）。
     - 轨迹口径：`visualize_predictions_folium.py --no_save_map`（输出 per-scene ADE/FDE/DirCos，便于抽样与汇总）。

### 预测“两个动作重复”现象验证与结论（11-03 晚）

- 实验目的：判定可视化中“两个动作重复”的根因，是“ABAB 交替”还是“模式坍缩（重复同一原语）”。

- 调试埋点（已加，`DECODER_DEBUG=1` 开启）：在解码器推理循环打印每步
  - 选中 token（picked）、Top-2 候选（top2）
  - 与前一步位移的方向余弦 `cos(prev,cur)`
  - 该步位移长度 `step_len`
  - Top-5 概率 `top5_prob`

  代码位置：
  ```540:555:/home/mahexing/SMART-main/smart/modules/agent_decoder.py
            # 调试打印：跟踪是否在相邻两步间发生反相（ABAB 交替）
            # 开关：DECODER_DEBUG=1
            _dbg = os.getenv('DECODER_DEBUG', '0') == '1'
            if _dbg and pos_a.shape[0] > 0:
                a0 = 0
                cur = pos_a[a0, hist_idx_end + 1 + t, :2] - pos_a[a0, hist_idx_end + t, :2]
                if t == 0:
                    prev = pos_a[a0, hist_idx_end, :2] - pos_a[a0, hist_idx_end - 1, :2]
                else:
                    prev = pos_a[a0, hist_idx_end + t, :2] - pos_a[a0, hist_idx_end + t - 1, :2]
                denom = (cur.norm() * prev.norm()).clamp_min(1e-6)
                cos_prev = float((cur @ prev) / denom)
                step_len = float(cur.norm())
                top2 = topk_idx_snapshot[a0, :2].tolist()
                picked = int(next_token_idx[a0].item())
                print(f"[DECODER_DEBUG] t={t:02d} picked={picked} top2={top2} cos(prev,cur)={cos_prev:.3f} step_len={step_len:.2f}")
  ```
  ```555:563:/home/mahexing/SMART-main/smart/modules/agent_decoder.py
            if topk_prob.shape[0] > 0 and topk_prob.shape[1] >= 5:
                probs5 = topk_prob[0, :5].detach().cpu().tolist()
                probs5_str = ",".join([f"{p:.3f}" for p in probs5])
                print(f"[DECODER_DEBUG] t={t:02d} top5_prob=[{probs5_str}]")
  ```

- 运行设置（单场景、仅日志）：
  ```bash
  DECODER_DEBUG=1 FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 \
  python visualize_predictions_folium.py \
    --config configs/train/train_maritime.yaml \
    --pretrain_ckpt logs/maritime_ft0deg_ckpts/epoch=24.ckpt \
    --split test --num_scenes 1 --no_save_map
  ```

- 关键日志（代表性）：
  - `t=0..15`：`picked=1012` 恒定；`cos(prev,cur)=0.991` 恒为正；`step_len=86.43` 恒定。
  - `top5_prob` 在 t≥1 呈尖峰：`top1≈0.57–0.82`，其余≈0.01–0.09。

- 结论：
  - 判定为“模式坍缩（重复同一原语）”，而非“ABAB 交替”。贪心 Top-1 在尖峰概率下持续选择同一 token（1012），形成固定方向与步长的重复图样（视觉上像“同一个动作反复”）。

- 影响与佐证：
  - 路径更直、步长固定；DirCos 中等；EndDisp 偏小（与当前可视化指标一致）。

- 下一步建议（按扰动强度由小到大）：
  1) Top-k 方向先验重排：对 top-k 候选按与参考方向的一致性加分后再选，保持确定性且可破坍缩；
  2) 反重复惩罚：若连续多步命中相同 token，对其 logit 施加小幅减分，打断连选；
  3) 采样式解码（小温度/Top-p）或叠加轻量残差位移头（影响较大，放后续）。

### 解码器方向先验重排与鲁棒性修复（11-04）

- **新增（方向先验重排，确定性）**: 在 `smart/modules/agent_decoder.py` 推理循环对 top-k 候选按 “logit + α·cos(候选步与参考方向)” 重新打分并取最大，保持确定性以抑制坍缩。
  - **环境变量**:
    - `DECODER_DIR_PRIOR=1`（启用，默认1）
    - `DECODER_DIR_WEIGHT=0.3`（方向权重，建议 0.2–0.4 网格化试验）
  - **调试**: `DECODER_DEBUG=1` 输出每步 dir_cos_topk 与 rerank_topk，定位是否尖峰导致重排无效。

- **可选开关（不改默认核心逻辑）**：
  - `DECODER_GREEDY=1`：由采样改为贪心取 top-1。
  - `DECODER_USE_DIFF_ANGLE=1`：旋转角由“位置差分角”替代 `head_a`；可叠加 `DECODER_ROT_OFFSET_DEG`。
  - `DECODER_ROT_OFFSET_DEG=0|90|-90|180`：常量偏置角（度）。
  - `DECODER_ROT_SIGN=pos|neg`：选择 `R(θ)` 或 `R(-θ)`；默认保持原先 `neg`。

- **适配与鲁棒性修复**：
  - **position 缺失回退**：`inference` 中若无 `data['agent']['position']`，回退到 `agent.x`；同时返回的 `gt` 同步回退。
  - **pt2a 保护**：仅当存在 `map_enc['x_pt']` 且 `edge_index_pl2a` 有边时才执行 pt2a 交互（海事无图安全）。
  - **维度对齐（XY）**：
    - 地图→代理相对位置与方向只在 XY 上计算，避免 3 vs 8 维度不匹配。
    - 候选相对位移与基点相加、以及预测写回 `pos_a` 时，仅更新前两维 `:2`（避免 2 vs 8）。
  - **去硬编码步长**：将 `expand(..., 6, 4, 2)` 等替换为 `self.shift+1`，与数据步长一致。

- **现象与结论（代表性一次运行）**：
  - 在 top-1 概率极尖峰、top-k 候选方向余弦接近 1 的情况下，方向先验重排对排序影响有限，仍会持续选择同一 token；但路径长度与稳定性相较早期有所改善。
  - 如需进一步破坍缩，建议叠加“步长先验（偏好与参考步长接近）”与“受控反重复（≥K次小降权）”。

- **排错与修复记录（关键栈回溯 → 修复）**：
  - `KeyError: 'position'` → 推理中改为 `position` 缺失回退到 `agent.x`。
  - `RuntimeError: size 3 vs 8`（map→agent 减法）→ 仅用 XY 做相对位置。
  - `RuntimeError: size 2 vs 8`（相对位移与基点求和/写回）→ 基点与写回均仅更新 `:2`。
  - `SyntaxError: '+'`（误黏贴前缀）→ 移除多余字符。

- **运行命令（推荐）**：
  - 可视化（4 场景）：
    ```bash
    cd /home/mahexing/SMART-main
    CKPT="$(ls -t logs/maritime_ft0deg_ckpts/*.ckpt | head -n1)"
    FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 \
    DECODER_DIR_PRIOR=1 DECODER_DIR_WEIGHT=0.3 \
    python visualize_predictions_folium.py \
      --config configs/train/train_maritime.yaml \
      --pretrain_ckpt "$CKPT" \
      --split test --num_scenes 4
    ```
  - 只打指标（均匀抽样 200，不生成 HTML）：
    ```bash
    cd /home/mahexing/SMART-main
    FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 \
    DECODER_DIR_PRIOR=1 DECODER_DIR_WEIGHT=0.3 \
    python visualize_predictions_folium.py \
      --config configs/train/train_maritime.yaml \
      --pretrain_ckpt "$CKPT" \
      --split test --num_scenes 200 \
      --sample_mode uniform --no_save_map
    ```
  - Lightning 验证（val_cls_acc / val_minADE / val_minFDE）：
    ```bash
    cd /home/mahexing/SMART-main
    python eval_test.py \
      --config configs/train/train_maritime.yaml \
      --pretrain_ckpt "$CKPT" \
      --split test
    ```

- **后续建议**：
  - 网格化搜索 `DECODER_DIR_WEIGHT` 与 `DECODER_ROT_OFFSET_DEG`（如 {0, 90, -90, 180}）。
  - 叠加步长先验与受控反重复以进一步打破坍缩；必要时引入轻量“残差回归头”细化位移。

### 方向来源与旋转设置网格化结果（11-04 晚）

- 设定与目的：在海事无地图推理下，固定均匀抽样 200 场景、仅打印指标（--no_save_map），网格化验证旋转角来源与符号/偏置对方向一致性的影响。
  - 固定：`FOLIUM_USE_REF_ANCHOR=1`、`FOLIUM_DISABLE_AUTO_AXIS=1`、`FOLIUM_SAMPLE_MODE=uniform`。
  - 网格：`DECODER_USE_DIFF_ANGLE=1`，`DECODER_ROT_SIGN∈{pos,neg}` × `DECODER_ROT_OFFSET_DEG∈{0,90,-90,180}`。
  - 汇总（DirCos 平均）：
    - pos+0° = 0.127（最佳）
    - pos+90° = 0.064；pos+180° = -0.119；pos-90° = -0.066
    - 所有 neg 组合 ≈ 0 或负值

- 结论
  - 使用“位置差分角 + R(θ) 正号 + 0° 偏置”方向一致性最佳，坐实“解码器旋转号/偏置”为主因之一。
  - 推荐默认：`DECODER_USE_DIFF_ANGLE=1`、`DECODER_ROT_SIGN=pos`、`DECODER_ROT_OFFSET_DEG=0`。

- 1000 样本基线复核（pos+0°，差分角）
  - 结果：`ADE≈947.26 m`、`FDE≈1691.83 m`、`DirCos≈0.114`。
  - 含义：相较早期（低至≈0.01），方向一致性显著提升，但仍有改进空间（FDE 较大）。

- 说明与开关
  - `head` 来自预处理的 `theta`，默认由原始 COG 转数学角得到；若 `DECODER_USE_DIFF_ANGLE=0` 则用 `head`，否则用“位置差分角”。
  - 可叠加“方向先验重排”：`DECODER_DIR_PRIOR=1`，`DECODER_DIR_WEIGHT∈{0.2,0.3,0.4}`，并可设 `DECODER_GREEDY=1` 去除采样噪声。

- 快速复现场命令
  - 网格脚本（200 场景，自动汇总）：
    ```bash
    cd /home/mahexing/SMART-main
    bash scripts/run_decoder_ab_grid.sh
    ```
  - 1000 样本基线（pos+0°，差分角）：
    ```bash
    cd /home/mahexing/SMART-main
    CKPT="$(ls -t logs/maritime_ft0deg_ckpts/*.ckpt 2>/dev/null | head -n1)"; \
    [ -z "$CKPT" ] && CKPT="$(ls -t logs/maritime_checkpoints/*.ckpt | head -n1)"
    FOLIUM_USE_REF_ANCHOR=1 FOLIUM_DISABLE_AUTO_AXIS=1 FOLIUM_SAMPLE_MODE=uniform \
    DECODER_USE_DIFF_ANGLE=1 DECODER_ROT_SIGN=pos DECODER_ROT_OFFSET_DEG=0 \
    python visualize_predictions_folium.py \
      --config configs/train/train_maritime.yaml \
      --pretrain_ckpt "$CKPT" \
      --split test --num_scenes 1000 --no_save_map | tee metrics_pos0_diff_1000.log
    ```